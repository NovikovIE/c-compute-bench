#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>
#include <string.h>

// --- MERSENNE TWISTER (DO NOT MODIFY) ---
#define MT_N 624
#define MT_M 397
#define MT_MATRIX_A 0x9908b0dfUL
#define MT_UPPER_MASK 0x80000000UL
#define MT_LOWER_MASK 0x7fffffffUL

static uint32_t mt[MT_N];
static int mt_index = MT_N + 1;

void mt_seed(uint32_t seed) {
    mt[0] = seed;
    for (mt_index = 1; mt_index < MT_N; mt_index++) {
        mt[mt_index] = (1812433253UL * (mt[mt_index - 1] ^ (mt[mt_index - 1] >> 30)) + mt_index);
    }
}

uint32_t mt_rand(void) {
    uint32_t y;
    static const uint32_t mag01[2] = {0x0UL, MT_MATRIX_A};
    if (mt_index >= MT_N) {
        if (mt_index > MT_N) {
             fprintf(stderr, "FATAL: Mersenne Twister not seeded.");
             exit(1);
        }
        for (int i = 0; i < MT_N - MT_M; i++) {
            y = (mt[i] & MT_UPPER_MASK) | (mt[i + 1] & MT_LOWER_MASK);
            mt[i] = mt[i + MT_M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (int i = MT_N - MT_M; i < MT_N - 1; i++) {
            y = (mt[i] & MT_UPPER_MASK) | (mt[i + 1] & MT_LOWER_MASK);
            mt[i] = mt[i + (MT_M - MT_N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[MT_N - 1] & MT_UPPER_MASK) | (mt[0] & MT_LOWER_MASK);
        mt[MT_N - 1] = mt[MT_M - 1] ^ (y >> 1) ^ mag01[y & 0x1UL];
        mt_index = 0;
    }
    y = mt[mt_index++];
    y ^= (y >> 11); y ^= (y << 7) & 0x9d2c5680UL; y ^= (y << 15) & 0xefc60000UL; y ^= (y >> 18);
    return y;
}
// --- END MERSENNE TWISTER ---

// --- BENCHMARK DATA STRUCTURES ---

// Type System
typedef enum { T_VAR, T_CONST, T_FUNC } TypeKind;
struct Type; // Forward declaration
typedef struct { struct Type* from; struct Type* to; } FuncType;

typedef struct Type {
    TypeKind kind;
    union {
        int var_id;     // Type variable ID
        int const_id;   // Type constant ID (e.g., 0 for Int, 1 for Bool)
        FuncType func;  // Function type T1 -> T2
    } data;
} Type;

// Expression AST
typedef enum { E_VAR, E_LAMBDA, E_APP, E_LET } ExprKind;
struct Expr; // Forward declaration
typedef struct { const char* name; struct Expr* body; } Lambda;
typedef struct { struct Expr* func; struct Expr* arg; } App;
typedef struct { const char* name; struct Expr* binding; struct Expr* body; } Let;

typedef struct Expr {
    ExprKind kind;
    union {
        const char* var_name;
        Lambda lambda;
        App app;
        Let let_expr;
    } data;
} Expr;

// Type Environment (for mapping variable names to types)
typedef struct TypeEnv {
    const char* name;
    Type* type;
    struct TypeEnv* next;
} TypeEnv;

// --- GLOBAL STATE ---
typedef struct {
    // Parameters
    int expression_tree_size;
    int num_let_bindings;

    // Data
    Expr* root_expression;
    char** var_name_pool;
    int var_name_pool_size;

    // Result
    long final_result;

    // Type Inference State
    int next_type_var_id;
    Type** substitutions;
    int max_type_vars;

} BenchmarkState;

static BenchmarkState* state;

// --- HELPER FUNCTIONS FOR SETUP ---

// Generate a random expression AST recursively
Expr* generate_expr_recursive(int* nodes_left, int* lets_left, int depth) {
    if (*nodes_left <= 0 || depth > 20) { // Base cases
        Expr* expr = (Expr*)malloc(sizeof(Expr));
        expr->kind = E_VAR;
        expr->data.var_name = state->var_name_pool[mt_rand() % state->var_name_pool_size];
        (*nodes_left)--;
        return expr;
    }

    (*nodes_left)--;
    Expr* expr = (Expr*)malloc(sizeof(Expr));
    int choice = mt_rand() % 100;

    if (*lets_left > 0 && choice < 15) { // LET expression
        (*lets_left)--;
        expr->kind = E_LET;
        expr->data.let_expr.name = state->var_name_pool[mt_rand() % state->var_name_pool_size];
        expr->data.let_expr.binding = generate_expr_recursive(nodes_left, lets_left, depth + 1);
        expr->data.let_expr.body = generate_expr_recursive(nodes_left, lets_left, depth + 1);
    } else if (choice < 40) { // LAMBDA expression
        expr->kind = E_LAMBDA;
        expr->data.lambda.name = state->var_name_pool[mt_rand() % state->var_name_pool_size];
        expr->data.lambda.body = generate_expr_recursive(nodes_left, lets_left, depth + 1);
    } else if (choice < 80) { // APPLICATION expression
        expr->kind = E_APP;
        expr->data.app.func = generate_expr_recursive(nodes_left, lets_left, depth + 1);
        expr->data.app.arg = generate_expr_recursive(nodes_left, lets_left, depth + 1);
    } else { // VARIABLE expression
        expr->kind = E_VAR;
        expr->data.var_name = state->var_name_pool[mt_rand() % state->var_name_pool_size];
    }
    return expr;
}

// --- BENCHMARK FUNCTIONS ---

void setup_benchmark(int argc, char* argv[]) {
    if (argc != 4) {
        fprintf(stderr, "Usage: %s <expression_tree_size> <num_let_bindings> <seed>\n", argv[0]);
        exit(1);
    }

    state = (BenchmarkState*)malloc(sizeof(BenchmarkState));
    if (!state) { perror("Failed to allocate state"); exit(1); }

    state->expression_tree_size = atoi(argv[1]);
    state->num_let_bindings = atoi(argv[2]);
    uint32_t seed = atoi(argv[3]);
    mt_seed(seed);

    state->final_result = 0;

    // Create a pool of variable names to reuse strings
    state->var_name_pool_size = 500;
    state->var_name_pool = (char**)malloc(state->var_name_pool_size * sizeof(char*));
    for (int i = 0; i < state->var_name_pool_size; ++i) {
        state->var_name_pool[i] = (char*)malloc(16 * sizeof(char));
        sprintf(state->var_name_pool[i], "v%d", i);
    }

    // Generate the expression tree
    int nodes_to_generate = state->expression_tree_size;
    int lets_to_generate = state->num_let_bindings;
    state->root_expression = generate_expr_recursive(&nodes_to_generate, &lets_to_generate, 0);

    // Initialize type inference state
    state->next_type_var_id = 0;
    state->max_type_vars = state->expression_tree_size * 2; // Estimate needed size
    state->substitutions = (Type**)calloc(state->max_type_vars, sizeof(Type*));
    if (!state->substitutions) { perror("Failed to allocated substitutions"); exit(1); }
}

// --- COMPUTATION (HINDLEY-MILNER INFERENCE) ---
void free_type(Type* t);

Type* new_type() {
    return (Type*)malloc(sizeof(Type));
}

Type* new_type_var() {
    if (state->next_type_var_id >= state->max_type_vars) {
        // This is a failure case for the benchmark, indicating under-provisioning.
        // We'll just wrap around, which will cause type errors but prevent crashing.
        state->next_type_var_id = 0;
    }
    Type* t = new_type();
    t->kind = T_VAR;
    t->data.var_id = state->next_type_var_id++;
    return t;
}

Type* new_type_const(int id) {
    Type* t = new_type();
    t->kind = T_CONST;
    t->data.const_id = id;
    return t;
}

Type* apply_substitutions(Type* t);
void unify(Type* t1, Type* t2);

int occurs_check(int var_id, Type* t) {
    Type* actual_t = apply_substitutions(t);
    if (actual_t->kind == T_VAR) {
        return actual_t->data.var_id == var_id;
    }
    if (actual_t->kind == T_FUNC) {
        return occurs_check(var_id, actual_t->data.func.from) || occurs_check(var_id, actual_t->data.func.to);
    }
    return 0;
}

Type* apply_substitutions(Type* t) {
    if (t->kind == T_VAR) {
        Type* sub = state->substitutions[t->data.var_id];
        if (sub) {
            return apply_substitutions(sub);
        }
    }
    return t;
}

void unify(Type* t1, Type* t2) {
    Type* a = apply_substitutions(t1);
    Type* b = apply_substitutions(t2);

    if (a->kind == T_VAR) {
        if (!occurs_check(a->data.var_id, b)) {
            state->substitutions[a->data.var_id] = b;
            state->final_result += a->data.var_id;
        }
    } else if (b->kind == T_VAR) {
        unify(b, a); // Reuse the first case
    } else if (a->kind == T_CONST && b->kind == T_CONST) {
        if (a->data.const_id != b->data.const_id) { /* Type Error */ }
        state->final_result += a->data.const_id;
    } else if (a->kind == T_FUNC && b->kind == T_FUNC) {
        unify(a->data.func.from, b->data.func.from);
        unify(a->data.func.to, b->data.func.to);
    }
    // Else: Type Error, do nothing for benchmark
}

Type* find_in_env(TypeEnv* env, const char* name) {
    while (env) {
        if (strcmp(env->name, name) == 0) {
            return env->type;
        }
        env = env->next;
    }
    return NULL;
}

Type* infer(Expr* expr, TypeEnv* env) {
    switch(expr->kind) {
        case E_VAR: {
            Type* t = find_in_env(env, expr->data.var_name);
            if (t) return t;
            return new_type_var(); // Assume global variables have fresh types
        }
        case E_LAMBDA: {
            Type* arg_type = new_type_var();
            TypeEnv new_env = { expr->data.lambda.name, arg_type, env };
            Type* body_type = infer(expr->data.lambda.body, &new_env);
            Type* result_type = new_type();
            result_type->kind = T_FUNC;
            result_type->data.func.from = arg_type;
            result_type->data.func.to = body_type;
            return result_type;
        }
        case E_APP: {
            Type* func_type = infer(expr->data.app.func, env);
            Type* arg_type = infer(expr->data.app.arg, env);
            Type* result_type = new_type_var();
            Type* expected_func_type = new_type();
            expected_func_type->kind = T_FUNC;
            expected_func_type->data.func.from = arg_type;
            expected_func_type->data.func.to = result_type;
            unify(func_type, expected_func_type);
            return result_type;
        }
        case E_LET: {
            Type* binding_type = infer(expr->data.let_expr.binding, env);
            TypeEnv new_env = { expr->data.let_expr.name, binding_type, env };
            return infer(expr->data.let_expr.body, &new_env);
        }
    }
    return NULL; // Should not be reached
}

void run_computation() {
    state->next_type_var_id = 0;
    // Re-zero substitutions for a clean run, though it's calloc'd
    memset(state->substitutions, 0, state->max_type_vars * sizeof(Type*));
    
    Type* result_type = infer(state->root_expression, NULL);
    // Result is accumulated in state->final_result during unification
    // We don't free the result_type as its components might be shared or part of substitutions
}

// --- CLEANUP ---

void free_expr_recursive(Expr* expr) {
    if (!expr) return;
    switch (expr->kind) {
        case E_LAMBDA:
            free_expr_recursive(expr->data.lambda.body);
            break;
        case E_APP:
            free_expr_recursive(expr->data.app.func);
            free_expr_recursive(expr->data.app.arg);
            break;
        case E_LET:
            free_expr_recursive(expr->data.let_expr.binding);
            free_expr_recursive(expr->data.let_expr.body);
            break;
        case E_VAR:
            break;
    }
    free(expr);
}

void cleanup() {
    free_expr_recursive(state->root_expression);
    for (int i = 0; i < state->var_name_pool_size; ++i) {
        free(state->var_name_pool[i]);
    }
    free(state->var_name_pool);
    free(state->substitutions);
    free(state);
}

// --- MAIN ---

int main(int argc, char *argv[]) {
    struct timespec start, end;

    setup_benchmark(argc, argv);

    clock_gettime(CLOCK_MONOTONIC, &start);
    run_computation();
    clock_gettime(CLOCK_MONOTONIC, &end);

    cleanup();

    double time_taken = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;

    printf("%ld\n", state->final_result);
    fprintf(stderr, "%.6f", time_taken);

    return 0;
}
