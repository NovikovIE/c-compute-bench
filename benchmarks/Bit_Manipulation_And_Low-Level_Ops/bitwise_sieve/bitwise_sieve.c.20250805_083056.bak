#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <stdint.h>\n#include <math.h>\n\n// --- Mersenne Twister (MT19937) Generator ---\n// Included verbatim as required\n#define MT_N 624\n#define MT_M 397\n#define MT_MATRIX_A 0x9908b0dfUL\n#define MT_UPPER_MASK 0x80000000UL\n#define MT_LOWER_MASK 0x7fffffffUL\n\nstatic uint32_t mt[MT_N];\nstatic int mt_index = MT_N + 1;\n\nvoid mt_seed(uint32_t seed) {\n    mt[0] = seed;\n    for (mt_index = 1; mt_index < MT_N; mt_index++) {\n        mt[mt_index] = (1812433253UL * (mt[mt_index - 1] ^ (mt[mt_index - 1] >> 30)) + mt_index);\n    }\n}\n\nuint32_t mt_rand(void) {\n    uint32_t y;\n    static const uint32_t mag01[2] = {0x0UL, MT_MATRIX_A};\n    if (mt_index >= MT_N) {\n        if (mt_index > MT_N) {\n             fprintf(stderr, \"FATAL: Mersenne Twister not seeded.\");\n             exit(1);\n        }\n        for (int i = 0; i < MT_N - MT_M; i++) {\n            y = (mt[i] & MT_UPPER_MASK) | (mt[i + 1] & MT_LOWER_MASK);\n            mt[i] = mt[i + MT_M] ^ (y >> 1) ^ mag01[y & 0x1UL];\n        }\n        for (int i = MT_N - MT_M; i < MT_N - 1; i++) {\n            y = (mt[i] & MT_UPPER_MASK) | (mt[i + 1] & MT_LOWER_MASK);\n            mt[i] = mt[i + (MT_M - MT_N)] ^ (y >> 1) ^ mag01[y & 0x1UL];\n        }\n        y = (mt[MT_N - 1] & MT_UPPER_MASK) | (mt[0] & MT_LOWER_MASK);\n        mt[MT_N - 1] = mt[MT_M - 1] ^ (y >> 1) ^ mag01[y & 0x1UL];\n        mt_index = 0;\n    }\n    y = mt[mt_index++];\n    y ^= (y >> 11); y ^= (y << 7) & 0x9d2c5680UL; y ^= (y << 15) & 0xefc60000UL; y ^= (y >> 18);\n    return y;\n}\n// --- End of Mersenne Twister ---\n\n// --- Benchmark Globals ---\ntypedef struct {\n    uint32_t *sieve_array;  // Bit array for the sieve\n    int upper_limit;        // The upper bound to search for primes\n    long long prime_count;  // The final result\n} BenchmarkData;\n\nstatic BenchmarkData g_data;\n\n// --- Benchmark Functions ---\n\n/**\n * @brief Sets up the Sieve of Eratosthenes benchmark.\n *\n * Parses command-line arguments for the upper limit and a random seed.\n * Allocates a bit array on the heap large enough to hold primality\n * information for all numbers up to 'upper_limit'.\n * Although the sieve itself is deterministic, the random seed is initialized\n * as per the requirements.\n * The bit array is initialized to 0 using calloc, representing all numbers as potentially prime.\n * 0 and 1 are explicitly marked as not prime.\n */\nvoid setup_benchmark(int argc, char *argv[]) {\n    if (argc != 3) {\n        fprintf(stderr, \"Usage: %s <upper_limit> <seed>\\n\", argv[0]);\n        exit(1);\n    }\n\n    g_data.upper_limit = atoi(argv[1]);\n    uint32_t seed = (uint32_t)atoi(argv[2]);\n    \n    if (g_data.upper_limit < 2) {\n        fprintf(stderr, \"Error: upper_limit must be at least 2.\\n\");\n        exit(1);\n    }\n\n    // Seed the random number generator (as required, though not used for data generation)\n    mt_seed(seed);\n\n    // Calculate the size of the bit array. Each uint32_t can hold 32 flags.\n    size_t num_words = (size_t)g_data.upper_limit / 32 + 1;\n    g_data.sieve_array = (uint32_t*) calloc(num_words, sizeof(uint32_t));\n    if (g_data.sieve_array == NULL) {\n        fprintf(stderr, \"Error: Memory allocation failed for sieve_array.\\n\");\n        exit(1);\n    }\n    \n    g_data.prime_count = 0;\n\n    // Mark 0 and 1 as not prime.\n    // Set bit 0:\n    g_data.sieve_array[0] |= (1U << 0);\n    // Set bit 1:\n    g_data.sieve_array[0] |= (1U << 1);\n}\n\n/**\n * @brief Runs the core computation: the Sieve of Eratosthenes.\n *\n * This function identifies all prime numbers up to `upper_limit` using a\n * bitwise sieve. \n * 1. It iterates from p = 2 up to sqrt(upper_limit).\n * 2. If a number p is found to be prime (its corresponding bit is 0),\n *    all multiples of p are marked as composite (their bits are set to 1).\n *    The marking starts from p*p, as smaller multiples would have been\n *    marked by smaller primes.\n * 3. After the sieve process, it counts all the numbers that remain marked\n *    as prime (bit is 0) and stores the total in `g_data.prime_count`.\n */\nvoid run_computation() {\n    int limit = g_data.upper_limit;\n    uint32_t *sieve = g_data.sieve_array;\n    int sqrt_limit = (int)sqrt((double)limit);\n\n    // Mark multiples of primes\n    for (int p = 2; p <= sqrt_limit; ++p) {\n        // Check if p is prime (if its bit is 0)\n        if (!((sieve[(size_t)p / 32] >> (p % 32)) & 1U)) {\n            // Mark all multiples of p starting from p*p\n            for (long long i = (long long)p * p; i <= limit; i += p) {\n                sieve[(size_t)i / 32] |= (1U << (i % 32));\n            }\n        }\n    }\n\n    // Count the primes\n    long long count = 0;\n    for (int i = 2; i <= limit; ++i) {\n        if (!((sieve[(size_t)i / 32] >> (i % 32)) & 1U)) {\n            count++;\n        }\n    }\n    g_data.prime_count = count;\n}\n\n\n/**\n * @brief Frees all memory allocated during setup.\n */\nvoid cleanup() {\n    free(g_data.sieve_array);\n    g_data.sieve_array = NULL;\n}\n\n\n// --- Main Function ---\nint main(int argc, char *argv[]) {\n    struct timespec start, end;\n\n    setup_benchmark(argc, argv);\n\n    clock_gettime(CLOCK_MONOTONIC, &start);\n    run_computation();\n    clock_gettime(CLOCK_MONOTONIC, &end);\n\n    cleanup();\n\n    double time_taken = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;\n\n    // Print the final result (total number of primes) to stdout\n    printf(\"%lld\\n\", g_data.prime_count);\n\n    // Print the execution time to stderr\n    fprintf(stderr, \"%.6f\", time_taken);\n\n    return 0;\n}\n