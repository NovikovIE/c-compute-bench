#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <limits.h>

// --- BEGIN MERSENNE TWISTER (DO NOT MODIFY) ---
#define MT_N 624
#define MT_M 397
#define MT_MATRIX_A 0x9908b0dfUL
#define MT_UPPER_MASK 0x80000000UL
#define MT_LOWER_MASK 0x7fffffffUL

static uint32_t mt[MT_N];
static int mt_index = MT_N + 1;

void mt_seed(uint32_t seed) {
    mt[0] = seed;
    for (mt_index = 1; mt_index < MT_N; mt_index++) {
        mt[mt_index] = (1812433253UL * (mt[mt_index - 1] ^ (mt[mt_index - 1] >> 30)) + mt_index);
    }
}

uint32_t mt_rand(void) {
    uint32_t y;
    static const uint32_t mag01[2] = {0x0UL, MT_MATRIX_A};
    if (mt_index >= MT_N) {
        if (mt_index > MT_N) {
                fprintf(stderr, "FATAL: Mersenne Twister not seeded.");
                exit(1);
        }
        for (int i = 0; i < MT_N - MT_M; i++) {
            y = (mt[i] & MT_UPPER_MASK) | (mt[i + 1] & MT_LOWER_MASK);
            mt[i] = mt[i + MT_M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (int i = MT_N - MT_M; i < MT_N - 1; i++) {
            y = (mt[i] & MT_UPPER_MASK) | (mt[i + 1] & MT_LOWER_MASK);
            mt[i] = mt[i + (MT_M - MT_N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[MT_N - 1] & MT_UPPER_MASK) | (mt[0] & MT_LOWER_MASK);
        mt[MT_N - 1] = mt[MT_M - 1] ^ (y >> 1) ^ mag01[y & 0x1UL];
        mt_index = 0;
    }
    y = mt[mt_index++];
    y ^= (y >> 11); y ^= (y << 7) & 0x9d2c5680UL; y ^= (y << 15) & 0xefc60000UL; y ^= (y >> 18);
    return y;
}
// --- END MERSENNE TWISTER ---

// --- DATA STRUCTURES ---
typedef struct {
    int x, y;
} Point;

typedef struct Node {
    Point pos;
    double g, h, f;
    struct Node* parent;
    char state; // 0: unvisited, 1: open, 2: closed
} Node;

// --- GLOBAL VARIABLES ---
static int grid_width;
static int grid_height;
static unsigned char* grid; // 1 for obstacle, 0 for walkable
static Node* all_nodes; // Flat array for all nodes on the grid

static Point start_pos;
static Point goal_pos;

static Node** open_set; // Min-heap (priority queue) of Node pointers
static int open_set_size;
static int open_set_capacity;

static int final_path_length = 0; // Result variable

// --- HELPER MACROS and FUNCTIONS ---
#define NODE_AT(x, y) (&all_nodes[(y) * grid_width + (x)])
#define SQRT2 1.41421356237

static inline int is_walkable(int x, int y) {
    return x >= 0 && x < grid_width && y >= 0 && y < grid_height && grid[y * grid_width + x] == 0;
}

static inline double heuristic(Point a, Point b) {
    double dx = fabs(a.x - b.x);
    double dy = fabs(a.y - b.y);
    return (dx + dy) + (SQRT2 - 2) * fmin(dx, dy); // Octile distance
}

// --- PRIORITY QUEUE (MIN-HEAP) FUNCTIONS ---
static void pq_swap(int i, int j) {
    Node* temp = open_set[i];
    open_set[i] = open_set[j];
    open_set[j] = temp;
}

static void pq_heapify_up(int i) {
    while (i > 0) {
        int p = (i - 1) / 2;
        if (open_set[i]->f < open_set[p]->f) {
            pq_swap(i, p);
            i = p;
        } else {
            break;
        }
    }
}

static void pq_heapify_down(int i) {
    int min_index = i;
    while (1) {
        int l = 2 * i + 1;
        int r = 2 * i + 2;
        if (l < open_set_size && open_set[l]->f < open_set[min_index]->f) {
            min_index = l;
        }
        if (r < open_set_size && open_set[r]->f < open_set[min_index]->f) {
            min_index = r;
        }
        if (min_index != i) {
            pq_swap(i, min_index);
            i = min_index;
        } else {
            break;
        }
    }
}

static void pq_push(Node* node) {
    if (open_set_size >= open_set_capacity) return;
    open_set[open_set_size] = node;
    node->state = 1;
    open_set_size++;
    pq_heapify_up(open_set_size - 1);
}

static Node* pq_pop() {
    if (open_set_size == 0) return NULL;
    Node* node = open_set[0];
    open_set[0] = open_set[open_set_size - 1];
    open_set_size--;
    pq_heapify_down(0);
    node->state = 2; // Mark as closed
    return node;
}

// --- JUMP POINT SEARCH CORE FUNCTIONS ---
Node* jump(int curr_x, int curr_y, int dx, int dy);

void identify_successors(Node* node) {
    int px, py, cx, cy;
    cx = node->pos.x;
    cy = node->pos.y;

    int neighbors[8][2];
    int num_neighbors = 0;

    if (node->parent) {
        px = node->parent->pos.x;
        py = node->parent->pos.y;
        int dx = (cx - px) / (abs(cx - px) ? abs(cx - px) : 1);
        int dy = (cy - py) / (abs(cy - py) ? abs(cy - py) : 1);

        if (dx != 0 && dy != 0) { // Diagonal move
            if (is_walkable(cx, cy + dy)) neighbors[num_neighbors++] = (int[2]){0, dy};
            if (is_walkable(cx + dx, cy)) neighbors[num_neighbors++] = (int[2]){dx, 0};
            if (is_walkable(cx, cy + dy) || is_walkable(cx + dx, cy)) {
                if (is_walkable(cx + dx, cy + dy)) neighbors[num_neighbors++] = (int[2]){dx, dy};
            }
            if (!is_walkable(cx - dx, cy) && is_walkable(cx - dx, cy + dy)) neighbors[num_neighbors++] = (int[2]){-dx, dy};
            if (!is_walkable(cx, cy - dy) && is_walkable(cx + dx, cy - dy)) neighbors[num_neighbors++] = (int[2]){dx, -dy};
        } else { // Straight move
            if (dx != 0) { // Horizontal
                if (is_walkable(cx + dx, cy)) neighbors[num_neighbors++] = (int[2]){dx, 0};
                if (!is_walkable(cx, cy + 1) && is_walkable(cx + dx, cy + 1)) neighbors[num_neighbors++] = (int[2]){dx, 1};
                if (!is_walkable(cx, cy - 1) && is_walkable(cx + dx, cy - 1)) neighbors[num_neighbors++] = (int[2]){dx, -1};
            } else { // Vertical
                if (is_walkable(cx, cy + dy)) neighbors[num_neighbors++] = (int[2]){0, dy};
                if (!is_walkable(cx + 1, cy) && is_walkable(cx + 1, cy + dy)) neighbors[num_neighbors++] = (int[2]){1, dy};
                if (!is_walkable(cx - 1, cy) && is_walkable(cx - 1, cy + dy)) neighbors[num_neighbors++] = (int[2]){-1, dy};
            }
        }
    } else { // Start node
        for (int dx = -1; dx <= 1; ++dx) {
            for (int dy = -1; dy <= 1; ++dy) {
                if (dx == 0 && dy == 0) continue;
                if(is_walkable(cx+dx, cy+dy)) neighbors[num_neighbors++] = (int[2]){dx, dy};
            }
        }
    }

    for (int i = 0; i < num_neighbors; ++i) {
        Node* jump_point = jump(cx, cy, neighbors[i][0], neighbors[i][1]);
        if (jump_point) {
            int jx = jump_point->pos.x;
            int jy = jump_point->pos.y;
            double new_g = node->g + heuristic(node->pos, jump_point->pos);

            if (jump_point->state == 0) { // Unvisited
                jump_point->g = new_g;
                jump_point->h = heuristic(jump_point->pos, goal_pos);
                jump_point->f = jump_point->g + jump_point->h;
                jump_point->parent = node;
                pq_push(jump_point);
            } else if (jump_point->state == 1 && new_g < jump_point->g) { // In open set
                jump_point->g = new_g;
                jump_point->f = jump_point->g + jump_point->h;
                jump_point->parent = node;
                 // For a simple heap, we can't efficiently update. A re-push would be an option,
                 // but we'll rely on the fact that A* with a consistent heuristic doesn't need re-opening of nodes.
            }
        }
    }
}

Node* jump(int curr_x, int curr_y, int dx, int dy) {
    int next_x = curr_x + dx;
    int next_y = curr_y + dy;

    if (!is_walkable(next_x, next_y)) return NULL;

    Node* next_node = NODE_AT(next_x, next_y);
    if (next_node->pos.x == goal_pos.x && next_node->pos.y == goal_pos.y) return next_node;

    // Check for forced neighbors (pruning rule)
    if (dx != 0 && dy != 0) { // Diagonal
        if ((is_walkable(next_x - dx, next_y + dy) && !is_walkable(next_x - dx, next_y)) ||
            (is_walkable(next_x + dx, next_y - dy) && !is_walkable(next_x, next_y - dy))) {
            return next_node;
        }
    } else { // Straight
        if (dx != 0) { // Horizontal
            if ((is_walkable(next_x + dx, next_y + 1) && !is_walkable(next_x, next_y + 1)) ||
                (is_walkable(next_x + dx, next_y - 1) && !is_walkable(next_x, next_y - 1))) {
                return next_node;
            }
        } else { // Vertical
            if ((is_walkable(next_x + 1, next_y + dy) && !is_walkable(next_x + 1, next_y)) ||
                (is_walkable(next_x - 1, next_y + dy) && !is_walkable(next_x - 1, next_y))) {
                return next_node;
            }
        }
    }

    // Recursive jump
    if (dx != 0 && dy != 0) { // Diagonal
        if (jump(next_x, next_y, dx, 0) || jump(next_x, next_y, 0, dy)) {
            return next_node;
        }
    }

    return jump(next_x, next_y, dx, dy);
}

void setup_benchmark(int argc, char* argv[]) {
    if (argc != 5) {
        fprintf(stderr, "Usage: %s <grid_width> <grid_height> <obstacle_%> <seed>\n", argv[0]);
        exit(1);
    }

    grid_width = atoi(argv[1]);
    grid_height = atoi(argv[2]);
    int obstacle_percentage = atoi(argv[3]);
    uint32_t seed = (uint32_t)atoi(argv[4]);

    mt_seed(seed);

    grid = (unsigned char*)malloc(grid_width * grid_height * sizeof(unsigned char));
    all_nodes = (Node*)malloc(grid_width * grid_height * sizeof(Node));
    open_set_capacity = grid_width * grid_height / 4;
    open_set = (Node**)malloc(open_set_capacity * sizeof(Node*));

    if (!grid || !all_nodes || !open_set) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }

    for (int y = 0; y < grid_height; ++y) {
        for (int x = 0; x < grid_width; ++x) {
            int idx = y * grid_width + x;
            grid[idx] = (mt_rand() % 100) < obstacle_percentage ? 1 : 0;
            all_nodes[idx].pos.x = x;
            all_nodes[idx].pos.y = y;
            all_nodes[idx].g = (double)INT_MAX;
            all_nodes[idx].h = 0.0;
            all_nodes[idx].f = (double)INT_MAX;
            all_nodes[idx].parent = NULL;
            all_nodes[idx].state = 0;
        }
    }

    start_pos = (Point){1, 1};
    goal_pos = (Point){grid_width - 2, grid_height - 2};

    // Ensure start and goal are walkable
    grid[start_pos.y * grid_width + start_pos.x] = 0;
    grid[goal_pos.y * grid_width + goal_pos.x] = 0;
}

void run_computation() {
    Node* start_node = NODE_AT(start_pos.x, start_pos.y);
    start_node->g = 0.0;
    start_node->h = heuristic(start_pos, goal_pos);
    start_node->f = start_node->h;

    open_set_size = 0;
    pq_push(start_node);

    Node* current = NULL;
    while (open_set_size > 0) {
        current = pq_pop();

        if (current->pos.x == goal_pos.x && current->pos.y == goal_pos.y) {
            break; // Goal found
        }

        identify_successors(current);
    }

    // Accumulate result
    int path_len = 0;
    if (current && current->pos.x == goal_pos.x && current->pos.y == goal_pos.y) {
        Node* path_node = current;
        while (path_node != NULL) {
            path_len++;
            path_node = path_node->parent;
        }
    }
    final_path_length = path_len;
}

void cleanup() {
    free(grid);
    free(all_nodes);
    free(open_set);
}

int main(int argc, char* argv[]) {
    struct timespec start, end;

    setup_benchmark(argc, argv);

    clock_gettime(CLOCK_MONOTONIC, &start);
    run_computation();
    clock_gettime(CLOCK_MONOTONIC, &end);

    cleanup();

    double time_taken = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;

    printf("%d\n", final_path_length);
    fprintf(stderr, "%.6f", time_taken);

    return 0;
}
