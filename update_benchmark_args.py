import os
import pprint
from all_benchmarks import all_benchmarks as all_benchmarks_original
import re

# --- SCRIPT CONFIGURATION ---
BENCHMARK_ROOT_DIR = "benchmarks"
OUTPUT_FILE = "updated_all_benchmarks.py"


def update_benchmarks_from_files():
    """
    Traverses the benchmark directories, reads the updated 'args.txt' files,
    and constructs a new 'all_benchmarks' dictionary.
    """
    updated_all_benchmarks = {}
    found_count = 0
    fallback_count = 0

    print(f"Starting scan of '{BENCHMARK_ROOT_DIR}' directory...")

    for theme_name, (theme_desc, programs) in all_benchmarks_original.items():
        theme_dir_name = theme_name.replace(" ", "_").lower()
        updated_programs = {}
        updated_all_benchmarks[theme_name] = (theme_desc, updated_programs)
        
        print(f"\nProcessing Theme: {theme_name}")

        for prog_name, original_params in programs.items():
            args_file_path = os.path.join(BENCHMARK_ROOT_DIR, theme_dir_name, prog_name, "args.txt")
            
            try:
                with open(args_file_path, 'r', encoding='utf-8') as f:
                    content = f.read().strip()
                    if content:
                        new_params = [p.strip() for p in content.split(',') if p.strip()]
                        updated_programs[prog_name] = new_params
                        print(f"  - {prog_name}: Found new args -> {new_params}")
                        found_count += 1
                    else:
                        print(f"  - {prog_name}: 'args.txt' is empty. Using original parameters.")
                        updated_programs[prog_name] = original_params
                        fallback_count += 1
            except FileNotFoundError:
                print(f"  - {prog_name}: 'args.txt' not found. Using original parameters.")
                updated_programs[prog_name] = original_params
                fallback_count += 1
            except Exception as e:
                print(f"  - {prog_name}: An error occurred: {e}. Using original parameters.")
                updated_programs[prog_name] = original_params
                fallback_count += 1

    return updated_all_benchmarks, found_count, fallback_count

def save_updated_dictionary(updated_dict, filename):
    """
    Saves the updated dictionary to a Python file using custom manual formatting
    to meet the specific one-line requirements for descriptions and arg lists.
    """
    print(f"\nManually formatting and writing updated dictionary to '{filename}'...")
    
    output_lines = []
    
    # Header for the file
    output_lines.append("# This file was auto-generated by the update_benchmarks.py script.")
    output_lines.append("# It contains the 'all_benchmarks' dictionary with parameters updated")
    output_lines.append("# from the 'args.txt' files found in the output directories.")
    output_lines.append("")
    output_lines.append("all_benchmarks = {")

    # Iterate through each theme in the dictionary
    for i, (theme_name, (theme_desc, programs)) in enumerate(updated_dict.items()):
        # 1. Format the theme name and the opening parenthesis of the tuple
        output_lines.append(f'    "{theme_name}": (')
        
        # 2. Format the theme description on a single line
        # Replace newlines and excessive whitespace with a single space, and escape quotes.
        clean_desc = re.sub(r'\s+', ' ', theme_desc).strip().replace('"', '\\"')
        output_lines.append(f'        "{clean_desc}",')
        
        # 3. Format the programs dictionary
        output_lines.append('        {')
        
        for j, (prog_name, params) in enumerate(programs.items()):
            # Format the list of parameters into a single-line string: `["p1", "p2", ...]`
            params_str = f'[{", ".join(f'"{p}"' for p in params)}]'
            
            # Add a trailing comma unless it's the last program in the theme
            comma = "," if j < len(programs) - 1 else ""
            output_lines.append(f'            "{prog_name}": {params_str}{comma}')
            
        output_lines.append('        }')
        
        # Add a trailing comma unless it's the last theme in the whole dictionary
        comma = "," if i < len(updated_dict) - 1 else ""
        output_lines.append(f'    ){comma}')

    output_lines.append("}")

    # Join all the generated lines into a single string
    file_content = "\n".join(output_lines)
    
    # Write the final content to the file
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(file_content)
        print(f" -> Successfully created '{filename}' with custom formatting.")
    except IOError as e:
        print(f"Error: Failed to write to file '{filename}'. Reason: {e}")


if __name__ == "__main__":
    if not all_benchmarks_original:
        print("Error: The 'all_benchmarks_original' dictionary is empty. Please paste your data into the script.")
    else:
        updated_dict, found, fallback = update_benchmarks_from_files()
        save_updated_dictionary(updated_dict, OUTPUT_FILE)
        
        print("\n--- Summary ---")
        print(f"Total benchmarks processed: {found + fallback}")
        print(f"Updated from 'args.txt': {found}")
        print(f"Used original/fallback args: {fallback}")